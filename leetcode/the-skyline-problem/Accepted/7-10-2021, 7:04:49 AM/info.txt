{"id":519995569,"lang":"python3","time":"3 weeks, 3 days","timestamp":1625868289,"status_display":"Accepted","runtime":"176 ms","url":"/submissions/detail/519995569/","is_pending":"Not Pending","title":"The Skyline Problem","memory":"18.9 MB","code":"class Solution:\n    def getSkyline(self, buildings: 'List[List[int]]') -> 'List[List[int]]':\n        \"\"\"\n        Divide-and-conquer algorithm to solve skyline problem,\n        which is similar with the merge sort algorithm.\n        \"\"\"\n        n = len(buildings)\n        # The base cases\n        if n == 0:\n            return []\n        if n == 1:\n            x_start, x_end, y = buildings[0]\n            return [[x_start, y], [x_end, 0]]\n\n        # If there is more than one building,\n        # recursively divide the input into two subproblems.\n        left_skyline = self.getSkyline(buildings[: n // 2])\n        right_skyline = self.getSkyline(buildings[n // 2 :])\n\n        # Merge the results of subproblem together.\n        return self.merge_skylines(left_skyline, right_skyline)\n\n    def merge_skylines(self, left, right):\n        \"\"\"\n        Merge two skylines together.\n        \"\"\"\n        def update_output(x, y):\n            \"\"\"\n            Update the final output with the new element.\n            \"\"\"\n            # if skyline change is not vertical -\n            # add the new point\n            if not output or output[-1][0] != x:\n                output.append([x, y])\n            # if skyline change is vertical -\n            # update the last point\n            else:\n                output[-1][1] = y\n\n        def append_skyline(p, lst, n, y, curr_y):\n            \"\"\"\n            Append the rest of the skyline elements with indice (p, n)\n            to the final output.\n            \"\"\"\n            while p < n:\n                x, y = lst[p]\n                p += 1\n                if curr_y != y:\n                    update_output(x, y)\n                    curr_y = y\n\n        n_l, n_r = len(left), len(right)\n        p_l = p_r = 0\n        curr_y  = left_y = right_y = 0\n        output = []\n\n        # while we're in the region where both skylines are present\n        while p_l < n_l and p_r < n_r:\n            point_l, point_r = left[p_l], right[p_r]\n            # pick up the smallest x\n            if point_l[0] < point_r[0]:\n                x, left_y = point_l\n                p_l += 1\n            else:\n                x, right_y = point_r\n                p_r += 1\n            # max height (i.e. y) between both skylines\n            max_y = max(left_y, right_y)\n            # if there is a skyline change\n            if curr_y != max_y:\n                update_output(x, max_y)\n                curr_y = max_y\n\n        # there is only left skyline\n        append_skyline(p_l, left, n_l, left_y, curr_y)\n\n        # there is only right skyline\n        append_skyline(p_r, right, n_r, right_y, curr_y)\n\n        return output","compare_result":"1111111111111111111111111111111111111111","title_slug":"the-skyline-problem"}