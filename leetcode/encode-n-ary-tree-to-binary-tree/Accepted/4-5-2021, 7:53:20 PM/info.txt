{"id":476752397,"lang":"python3","time":"3 months, 4 weeks","timestamp":1617620000,"status_display":"Accepted","runtime":"96 ms","url":"/submissions/detail/476752397/","is_pending":"Not Pending","title":"Encode N-ary Tree to Binary Tree","memory":"20.6 MB","code":"class Codec:\n    def encode(self, root):\n        #DFS for binary tree construction\n        def encode_recur(arr):\n            if not arr: return None\n            this = TreeNode(arr[0].val) #allocate TreeNode\n            left = arr[0].children #children goes to left\n            right = arr[1:] #nodes at same level goes to right\n            this.left = encode_recur(left)\n            this.right = encode_recur(right)    \n            return this    \n        if not root: return None\n        data = TreeNode(root.val) #allocate initial node\n        data.left = encode_recur(root.children) #call recursion\n        return data\n    \n\n    def decode(self, data):\n        #BFS for n-ary tree construction\n        if not data: return None\n        root = Node(data.val)\n        #use priority queue which preserves depth order\n        #root: root of n-ary tree, data: root of binary tree\n        que = deque([(root, data)]) #push root and data together\n        while que:\n            #ntn: n-ary tree node, #btn: binary tree node\n            ntn, btn = que.popleft()\n            nex_btn = btn.left if btn.left else None\n            children = []\n            while nex_btn: #this means we have children and should add them recursively\n                nex_ntn = Node(nex_btn.val) #allocate Node\n                children.append(nex_ntn) #add it to children\n                que.append((nex_ntn, nex_btn)) #add it to queue so it can be processed\n                nex_btn = nex_btn.right\n            ntn.children = children    \n        return root","compare_result":"1111111111111111111111111111111111111","title_slug":"encode-n-ary-tree-to-binary-tree"}