{"id":529540051,"lang":"python3","time":"6Â days","timestamp":1627459919,"status_display":"Accepted","runtime":"64 ms","url":"/submissions/detail/529540051/","is_pending":"Not Pending","title":"Binary Search Tree Iterator","memory":"20.8 MB","code":"# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.left = None\n#         self.right = None\n\nclass BSTIterator:\n\n    def __init__(self, root: TreeNode):\n\n        # Stack for the recursion simulation\n        self.stack = []\n\n        # Remember that the algorithm starts with a call to the helper function\n        # with the root node as the input\n        self._leftmost_inorder(root)\n\n    def _leftmost_inorder(self, root):\n\n        # For a given node, add all the elements in the leftmost branch of the tree\n        # under it to the stack.\n        while root:\n            self.stack.append(root)\n            root = root.left\n\n    def next(self) -> int:\n        \"\"\"\n        @return the next smallest number\n        \"\"\"\n\n        # Node at the top of the stack is the next smallest element\n        topmost_node = self.stack.pop()\n\n        # Need to maintain the invariant. If the node has a right child, call the\n        # helper function for the right child\n        if topmost_node.right:\n            self._leftmost_inorder(topmost_node.right)\n        return topmost_node.val\n\n    def hasNext(self) -> bool:\n        \"\"\"\n        @return whether we have a next smallest number\n        \"\"\"\n        return len(self.stack) > 0","compare_result":"1111111111111111111111111111111111111111111111111111111111111","title_slug":"binary-search-tree-iterator"}