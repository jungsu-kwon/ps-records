{"id":396269756,"lang":"cpp","time":"10 months, 3 weeks","timestamp":1600205040,"status_display":"Accepted","runtime":"284 ms","url":"/submissions/detail/396269756/","is_pending":"Not Pending","title":"LRU Cache","memory":"39.9 MB","code":"#include <iostream>\n#include <unordered_map>\n#include <algorithm>\n\nstruct LinkedList {\n    int val;\n\tint key;\n    LinkedList *next;\n\tLinkedList *prev;\n\n    LinkedList(int k,int x) : key(k), val(x), next(nullptr), prev(nullptr) {}\n};\n\nclass LRUCache {\npublic:\n\tint num_elems = 0 ; \n\tint num_max_elems = 0 ;\n\tstd::unordered_map<int,LinkedList*> hash;\n\tLinkedList* head; \n\tLinkedList* tail;\n\n\tLRUCache(int capacity) {\n\t\tnum_max_elems = capacity;\n\t\thead = new LinkedList(0,0);\n\t\ttail = new LinkedList(0,0);\n\t\thead->next = tail;\n\t\ttail->prev = head;\n\n\t}\n\n\tint get(int key) {\n\t\tif (hash.find(key) != hash.end())\n\t\t{\n\t\t\tauto curNode = hash[key];\n\t\t\tbringFront(curNode);\n\t\t\treturn curNode->val;\n\t\t}\n\t\treturn -1;\n\t}\n\tvoid print(){\n\t\tauto curNode = head;\n\t\twhile (curNode != nullptr){\n\t\t\tstd::cout << curNode->key << \" \" << curNode->val << std::endl;\n\t\t\tcurNode = curNode->next;\n\t\t}\n\t}\n\tvoid bringFront(LinkedList* node){\n\t\tauto prevNode = node->prev;\n\t\tauto nextNode = node->next;\n\n\t\tif (prevNode != nullptr && nextNode != nullptr)\n\t\t{\n\t\t\tprevNode->next = nextNode;\n\t\t\tnextNode->prev = prevNode;\n\t\t}\n\n\t\tauto firstNode = head->next;\n\t\thead->next = node;\n\t\tnode->prev = head;\n\n\t\tnode->next = firstNode;\n\t\tfirstNode->prev = node;\n\n\n\t}\n\n\tvoid put(int key, int value) \n\t{\n\t\tif (hash.find(key) != hash.end())\n\t\t{\n\t\t\thash[key]->val = value;\n\t\t\tbringFront(hash[key]);\n\t\t\treturn ;\n\t\t}\n\t\tLinkedList* nodeToAdd = nullptr;\n\t\tif (num_elems == num_max_elems)\n\t\t{\n\t\t\tauto nodeToPop = tail->prev;\n\t\t\thash.erase(nodeToPop->key);\n\n\t\t\tnodeToAdd = nodeToPop;\n\t\t\tnodeToAdd->key = key;\n\t\t\tnodeToAdd->val = value;\n\t\t\t\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnodeToAdd = new LinkedList(key,value);\n\t\t}\n\t\thash[key] = nodeToAdd;\n\t\tnum_elems = std::min(num_elems+1,num_max_elems);\n\t\tbringFront(nodeToAdd);\n\n\t}\n};\n\n/**\n *  * Your LRUCache object will be instantiated and called as such:\n *   * LRUCache* obj = new LRUCache(capacity);\n *    * int param_1 = obj->get(key);\n *     * obj->put(key,value);\n *      */\n","compare_result":"111111111111111111","title_slug":"lru-cache"}