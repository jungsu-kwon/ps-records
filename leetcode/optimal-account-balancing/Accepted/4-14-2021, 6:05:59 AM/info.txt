{"id":480277736,"lang":"python3","time":"3 months, 3 weeks","timestamp":1618347959,"status_display":"Accepted","runtime":"72 ms","url":"/submissions/detail/480277736/","is_pending":"Not Pending","title":"Optimal Account Balancing","memory":"15.1 MB","code":"from collections import defaultdict,Counter\nfrom typing import List\n\nclass Solution:\n    def get_balances(self,transactions : List[List[int]]) -> dict:\n        balances = defaultdict(int)\n\n        for src,dst,amount, in transactions:\n            balances[src] += amount\n            balances[dst] -= amount\n\n        return list(balances.values())\n        \n    def minTransfers(self, transactions: List[List[int]]) -> int:\n        balances = self.get_balances(transactions)\n\n        self.notes = {}\n\n        def dfs(balances : List[int], cur: int, path: int):\n            if not balances:\n                return path\n\n            if tuple(balances) in self.notes:\n                return path + self.notes[tuple(balances)]\n\n            res = float(\"inf\")\n            for i,balance in enumerate(balances):\n                if cur == 0:\n                    res = min(res,dfs(balances[:i] +\n                                      balances[i+1:],cur+balances[i],\n                                      path))\n                else:\n                    res = min(res,dfs(balances[:i] +\n                                      balances[i+1:],cur+balances[i],\n                                      path+1))\n            self.notes[tuple(balances)] = res - path\n            return res\n        return dfs(balances,0,0)\n\n        \n\n\n\n        \n\n        \n\n\n            \n\n\n\n\n        \n\n\n\n        \n","compare_result":"111111111111111111111111111111","title_slug":"optimal-account-balancing"}