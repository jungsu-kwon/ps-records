{"id":497766458,"lang":"cpp","time":"2 months, 1 week","timestamp":1621890570,"status_display":"Accepted","runtime":"12 ms","url":"/submissions/detail/497766458/","is_pending":"Not Pending","title":"Construct Binary Tree from Preorder and Inorder Traversal","memory":"26.7 MB","code":"#include <algorithm>\n#include<vector>\nusing namespace std;\n/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\nprivate:\n    TreeNode* helper(vector<int>::iterator pre_start,\n                     vector<int>::iterator pre_end,\n                     vector<int>::iterator in_start,\n                     vector<int>::iterator in_end\n    )\n    {\n        if (pre_start == pre_end || in_start == in_end)  \n            return nullptr;\n\n        auto root_val = *pre_start;\n\n        auto root = new TreeNode(root_val);\n\n        auto root_it = find(in_start,in_end,root_val);\n        auto offset  = distance(in_start,root_it);\n\n        root->left  = helper(pre_start+1,pre_start+1+offset,in_start,root_it);\n        root->right = helper(pre_start+1+offset,pre_end,root_it+1,in_end);\n        return root;\n\n    }\npublic:\n    TreeNode* buildTree(vector<int>& preorder, vector<int>& inorder) {\n        return helper(preorder.begin(),preorder.end(),inorder.begin(),inorder.end());\n        \n    }\n};","compare_result":"1111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111","title_slug":"construct-binary-tree-from-preorder-and-inorder-traversal"}