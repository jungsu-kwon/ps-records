{"id":401338851,"lang":"cpp","time":"10 months, 1 week","timestamp":1601199364,"status_display":"Accepted","runtime":"56 ms","url":"/submissions/detail/401338851/","is_pending":"Not Pending","title":"Serialize and Deserialize Binary Tree","memory":"30.7 MB","code":"\n\nclass Codec {\nprivate :\n\tint nNull = -10000;\npublic:\n\n    // Encodes a tree to a single string.\n\tstd::string  serialize(TreeNode* root) {\n\t\tstd::string strAns;\n\t\tif (root == nullptr) return strAns;\n\t\tstd::queue<TreeNode*> bfs;\n\t\tbfs.push(root);\n\n\t\tbool isValidBfs = true;\n\t\twhile (bfs.size())\n\t\t{\n\t\t\tauto bfsSize = bfs.size();\n\t\t\tfor(auto t = 0; t < bfsSize; ++t){\n\t\t\t\tauto node= bfs.front();\n\t\t\t\tbfs.pop();\n\t\t\t\tif (node != nullptr){\n\t\t\t\t\tstrAns += std::to_string(node->val) + \",\";\n                    bfs.push(node->left);\n                    bfs.push(node->right);\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tstrAns += \"n,\";\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\tstrAns.erase(strAns.find_last_not_of(\"n,\")+1);\n        return strAns;\n    }\n\tint findInt(std::string &strTree,int &start){\n\t\tif (start == strTree.npos) return nNull;\n\t\t\n        auto end = strTree.find(',',start);\n        std::string strSub;\n\t\tif (end == strTree.npos)\n\t\t{\n            strSub = strTree.substr(start);\n            start = end;\n\t\t}\n        else {\n            strSub = strTree.substr(start,end-start);\n            start = end + 1;\n        }\n\t\tif (strSub == \"n\"){\n\t\t   \treturn nNull;\n\t\t}\n\t\telse {\n\t\t\tint ret = std::stoi(strSub);\n\t\t\treturn  ret;\n\t\t}\n\t}\n\n\n    // Decodes your encoded data to tree.\n    TreeNode* deserialize(std::string strTree) {\n        //std::cout << strTree << std::endl;\n\t\tauto n = strTree.size();\n\t\tif (n == 0 ) return nullptr;\n\n\t\tint start = 0;\n\t\tTreeNode* root = new TreeNode(findInt(strTree,start));\n\t\tstd::queue<TreeNode*> queueParents;\n\t\tqueueParents.push(root);\n\n\t\tint nParentInd = 0;\n\t\twhile (start != strTree.npos){\n\t\t\tint leftVal = findInt(strTree,start);\n\t\t\tint rightVal = findInt(strTree,start);\n\t\t\tauto parentNode = queueParents.front() ;\n\t\t\tqueueParents.pop();\n\t\t\tif (parentNode != nullptr)\n\t\t\t{\n\t\t\t\tparentNode->left = (leftVal == nNull) ? nullptr : new TreeNode(leftVal);\n\t\t\t\tparentNode->right = (rightVal == nNull) ? nullptr : new TreeNode(rightVal);\n\t\t\t\tif (parentNode->left) queueParents.push(parentNode->left);\n\t\t\t\tif (parentNode->right) queueParents.push(parentNode->right);\n\t\t\t}\n            \n\n\t\t}\n\t\treturn root;\n\n    }\n};","compare_result":"11111111111111111111111111111111111111111111111111","title_slug":"serialize-and-deserialize-binary-tree"}