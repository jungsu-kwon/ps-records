{"id":401229694,"lang":"cpp","time":"10 months, 1 week","timestamp":1601178514,"status_display":"Time Limit Exceeded","runtime":"N/A","url":"/submissions/detail/401229694/","is_pending":"Not Pending","title":"Serialize and Deserialize Binary Tree","memory":"N/A","code":"#include <vector>\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\n\nclass Codec {\nprivate : \n\tint nNull = -10000;\npublic:\n\n    // Encodes a tree to a single string.\n\tstd::vector<int>  serialize(TreeNode* root) {\n\t\tstd::vector<int> vecAns;\n\t\tif (root == nullptr) return vecAns;\n\n\t\tstd::vector<TreeNode*> bfs{root};\n        bool nValidBfs = true;\n\t\twhile (nValidBfs){\n            nValidBfs = false;\n\t\t\tauto bfsSize = bfs.size();\n\t\t\tstd::vector<TreeNode*> vecChildren;\n\t\t\tfor (auto node : bfs)\n\t\t\t{\n\n\t\t\t\tif (node == nullptr){\n\t\t\t\t\tvecChildren.push_back(nullptr);\n\t\t\t\t\tvecChildren.push_back(nullptr);\n\t\t\t\t\tvecAns.push_back(nNull);\n\t\t\t\t}\n\t\t\t\telse{\n\t\t\t\t\tvecChildren.push_back(node->left);\n\t\t\t\t\tvecChildren.push_back(node->right);\n\t\t\t\t\tvecAns.push_back(node->val);\n                    if (node->left != nullptr || node->right != nullptr)\n                        nValidBfs = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tbfs = vecChildren;\n\t\t}\n\t\treturn vecAns;\n    }\n\n    // Decodes your encoded data to tree.\n    TreeNode* deserialize(std::vector<int> data) {\n\t\tauto n = data.size();\n\t\tif (n == 0 ) return nullptr;\n\t\tTreeNode* root = new TreeNode(data[0]);\n\t\tstd::vector<TreeNode*> vecParents{root};\n\n\t\tint nParentInd = 0;\n\t\tfor (auto t = 1 ; t < data.size(); ++t){\n\t\t\tauto leftVal = data[t];\n\t\t\tauto rightVal = (t+1 >= data.size()) ? nNull : data[t+1];\n\t\t\tauto parentNode = vecParents[nParentInd] ; \n\t\t\tif (parentNode != nullptr)\n\t\t\t{\n\t\t\t\tparentNode->left = (leftVal == nNull) ? nullptr : new TreeNode(leftVal);\n\t\t\t\tparentNode->right = (rightVal == nNull) ? nullptr : new TreeNode(rightVal);\n\t\t\t\tvecParents.push_back(parentNode->left);\n\t\t\t\tvecParents.push_back(parentNode->right);\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\tvecParents.push_back(nullptr);\n\t\t\t\tvecParents.push_back(nullptr);\n\t\t\t}\n\n\t\t\tt += 1 ;\n\t\t\tnParentInd += 1 ;\n\t\t}\n\t\treturn root;\n        \n    }\n};\n\n// Your Codec object will be instantiated and called as such:\n// Codec ser, deser;\n// TreeNode* ans = deser.deserialize(ser.serialize(root));\n","compare_result":"11111111111111111111111111111111111111111111111110","title_slug":"serialize-and-deserialize-binary-tree"}