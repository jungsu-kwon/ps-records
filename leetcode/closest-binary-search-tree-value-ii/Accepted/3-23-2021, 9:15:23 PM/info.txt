{"id":471418820,"lang":"python3","time":"4 months, 1 week","timestamp":1616501723,"status_display":"Accepted","runtime":"60 ms","url":"/submissions/detail/471418820/","is_pending":"Not Pending","title":"Closest Binary Search Tree Value II","memory":"16.5 MB","code":"from queue import PriorityQueue\nimport heapq\n# Definition for a binary tree node.\n# class TreeNode:\n#     def __init__(self, val=0, left=None, right=None):\n#         self.val = val\n#         self.left = left\n#         self.right = right\nclass Solution:\n\n    def inorder_traversal(self,root : TreeNode):\n        if not root:\n            return\n        self.inorder_traversal(root.left)\n        heapq.heappush(self.pq,(-abs(self.target-root.val),root.val))\n        if len(self.pq) == self.k+1:\n            heapq.heappop(self.pq)\n        self.inorder_traversal(root.right)\n            \n\n    def closestKValues(self, root: TreeNode, target: float, k: int) -> List[int]:\n        self.pq = []\n        self.k = k\n        self.target = target\n        self.inorder_traversal(root)\n\n        return [node[1] for node in self.pq]\n\n\n\n\n\n        \n        \n        \n","compare_result":"11111111111111111111111111111111111111111111111111111111111111111","title_slug":"closest-binary-search-tree-value-ii"}